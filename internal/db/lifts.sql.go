// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: lifts.sql

package db

import (
	"context"
	"database/sql"
)

const countLifts = `-- name: CountLifts :one
SELECT COUNT(*) FROM lifts
`

func (q *Queries) CountLifts(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLifts)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countLiftsFilteredByCompetition = `-- name: CountLiftsFilteredByCompetition :one
SELECT COUNT(*) FROM lifts WHERE is_competition_lift = ?
`

func (q *Queries) CountLiftsFilteredByCompetition(ctx context.Context, isCompetitionLift int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLiftsFilteredByCompetition, isCompetitionLift)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLift = `-- name: CreateLift :exec
INSERT INTO lifts (id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateLiftParams struct {
	ID                string         `json:"id"`
	Name              string         `json:"name"`
	Slug              string         `json:"slug"`
	IsCompetitionLift int64          `json:"is_competition_lift"`
	ParentLiftID      sql.NullString `json:"parent_lift_id"`
	CreatedAt         string         `json:"created_at"`
	UpdatedAt         string         `json:"updated_at"`
}

func (q *Queries) CreateLift(ctx context.Context, arg CreateLiftParams) error {
	_, err := q.db.ExecContext(ctx, createLift,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.IsCompetitionLift,
		arg.ParentLiftID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteLift = `-- name: DeleteLift :exec
DELETE FROM lifts WHERE id = ?
`

func (q *Queries) DeleteLift(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLift, id)
	return err
}

const getLift = `-- name: GetLift :one
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
WHERE id = ?
`

func (q *Queries) GetLift(ctx context.Context, id string) (Lift, error) {
	row := q.db.QueryRowContext(ctx, getLift, id)
	var i Lift
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.IsCompetitionLift,
		&i.ParentLiftID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLiftBySlug = `-- name: GetLiftBySlug :one
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
WHERE slug = ?
`

func (q *Queries) GetLiftBySlug(ctx context.Context, slug string) (Lift, error) {
	row := q.db.QueryRowContext(ctx, getLiftBySlug, slug)
	var i Lift
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.IsCompetitionLift,
		&i.ParentLiftID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const liftHasChildReferences = `-- name: LiftHasChildReferences :one
SELECT EXISTS(SELECT 1 FROM lifts WHERE parent_lift_id = ?) AS has_references
`

func (q *Queries) LiftHasChildReferences(ctx context.Context, parentLiftID sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, liftHasChildReferences, parentLiftID)
	var has_references int64
	err := row.Scan(&has_references)
	return has_references, err
}

const listLiftsByCreatedAtAsc = `-- name: ListLiftsByCreatedAtAsc :many
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
ORDER BY created_at ASC
LIMIT ? OFFSET ?
`

type ListLiftsByCreatedAtAscParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListLiftsByCreatedAtAsc(ctx context.Context, arg ListLiftsByCreatedAtAscParams) ([]Lift, error) {
	rows, err := q.db.QueryContext(ctx, listLiftsByCreatedAtAsc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lift{}
	for rows.Next() {
		var i Lift
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsCompetitionLift,
			&i.ParentLiftID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiftsByCreatedAtDesc = `-- name: ListLiftsByCreatedAtDesc :many
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListLiftsByCreatedAtDescParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListLiftsByCreatedAtDesc(ctx context.Context, arg ListLiftsByCreatedAtDescParams) ([]Lift, error) {
	rows, err := q.db.QueryContext(ctx, listLiftsByCreatedAtDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lift{}
	for rows.Next() {
		var i Lift
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsCompetitionLift,
			&i.ParentLiftID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiftsByNameAsc = `-- name: ListLiftsByNameAsc :many
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListLiftsByNameAscParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListLiftsByNameAsc(ctx context.Context, arg ListLiftsByNameAscParams) ([]Lift, error) {
	rows, err := q.db.QueryContext(ctx, listLiftsByNameAsc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lift{}
	for rows.Next() {
		var i Lift
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsCompetitionLift,
			&i.ParentLiftID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiftsByNameDesc = `-- name: ListLiftsByNameDesc :many
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
ORDER BY name DESC
LIMIT ? OFFSET ?
`

type ListLiftsByNameDescParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListLiftsByNameDesc(ctx context.Context, arg ListLiftsByNameDescParams) ([]Lift, error) {
	rows, err := q.db.QueryContext(ctx, listLiftsByNameDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lift{}
	for rows.Next() {
		var i Lift
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsCompetitionLift,
			&i.ParentLiftID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiftsFilteredByCompetitionByCreatedAtAsc = `-- name: ListLiftsFilteredByCompetitionByCreatedAtAsc :many
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
WHERE is_competition_lift = ?
ORDER BY created_at ASC
LIMIT ? OFFSET ?
`

type ListLiftsFilteredByCompetitionByCreatedAtAscParams struct {
	IsCompetitionLift int64 `json:"is_competition_lift"`
	Limit             int64 `json:"limit"`
	Offset            int64 `json:"offset"`
}

func (q *Queries) ListLiftsFilteredByCompetitionByCreatedAtAsc(ctx context.Context, arg ListLiftsFilteredByCompetitionByCreatedAtAscParams) ([]Lift, error) {
	rows, err := q.db.QueryContext(ctx, listLiftsFilteredByCompetitionByCreatedAtAsc, arg.IsCompetitionLift, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lift{}
	for rows.Next() {
		var i Lift
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsCompetitionLift,
			&i.ParentLiftID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiftsFilteredByCompetitionByCreatedAtDesc = `-- name: ListLiftsFilteredByCompetitionByCreatedAtDesc :many
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
WHERE is_competition_lift = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListLiftsFilteredByCompetitionByCreatedAtDescParams struct {
	IsCompetitionLift int64 `json:"is_competition_lift"`
	Limit             int64 `json:"limit"`
	Offset            int64 `json:"offset"`
}

func (q *Queries) ListLiftsFilteredByCompetitionByCreatedAtDesc(ctx context.Context, arg ListLiftsFilteredByCompetitionByCreatedAtDescParams) ([]Lift, error) {
	rows, err := q.db.QueryContext(ctx, listLiftsFilteredByCompetitionByCreatedAtDesc, arg.IsCompetitionLift, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lift{}
	for rows.Next() {
		var i Lift
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsCompetitionLift,
			&i.ParentLiftID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiftsFilteredByCompetitionByNameAsc = `-- name: ListLiftsFilteredByCompetitionByNameAsc :many
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
WHERE is_competition_lift = ?
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListLiftsFilteredByCompetitionByNameAscParams struct {
	IsCompetitionLift int64 `json:"is_competition_lift"`
	Limit             int64 `json:"limit"`
	Offset            int64 `json:"offset"`
}

func (q *Queries) ListLiftsFilteredByCompetitionByNameAsc(ctx context.Context, arg ListLiftsFilteredByCompetitionByNameAscParams) ([]Lift, error) {
	rows, err := q.db.QueryContext(ctx, listLiftsFilteredByCompetitionByNameAsc, arg.IsCompetitionLift, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lift{}
	for rows.Next() {
		var i Lift
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsCompetitionLift,
			&i.ParentLiftID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLiftsFilteredByCompetitionByNameDesc = `-- name: ListLiftsFilteredByCompetitionByNameDesc :many
SELECT id, name, slug, is_competition_lift, parent_lift_id, created_at, updated_at
FROM lifts
WHERE is_competition_lift = ?
ORDER BY name DESC
LIMIT ? OFFSET ?
`

type ListLiftsFilteredByCompetitionByNameDescParams struct {
	IsCompetitionLift int64 `json:"is_competition_lift"`
	Limit             int64 `json:"limit"`
	Offset            int64 `json:"offset"`
}

func (q *Queries) ListLiftsFilteredByCompetitionByNameDesc(ctx context.Context, arg ListLiftsFilteredByCompetitionByNameDescParams) ([]Lift, error) {
	rows, err := q.db.QueryContext(ctx, listLiftsFilteredByCompetitionByNameDesc, arg.IsCompetitionLift, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Lift{}
	for rows.Next() {
		var i Lift
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.IsCompetitionLift,
			&i.ParentLiftID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const slugExists = `-- name: SlugExists :one
SELECT EXISTS(SELECT 1 FROM lifts WHERE slug = ? AND id != ?) AS slug_exists
`

type SlugExistsParams struct {
	Slug string `json:"slug"`
	ID   string `json:"id"`
}

func (q *Queries) SlugExists(ctx context.Context, arg SlugExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, slugExists, arg.Slug, arg.ID)
	var slug_exists int64
	err := row.Scan(&slug_exists)
	return slug_exists, err
}

const slugExistsForNew = `-- name: SlugExistsForNew :one
SELECT EXISTS(SELECT 1 FROM lifts WHERE slug = ?) AS slug_exists
`

func (q *Queries) SlugExistsForNew(ctx context.Context, slug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, slugExistsForNew, slug)
	var slug_exists int64
	err := row.Scan(&slug_exists)
	return slug_exists, err
}

const updateLift = `-- name: UpdateLift :exec
UPDATE lifts
SET name = ?, slug = ?, is_competition_lift = ?, parent_lift_id = ?, updated_at = ?
WHERE id = ?
`

type UpdateLiftParams struct {
	Name              string         `json:"name"`
	Slug              string         `json:"slug"`
	IsCompetitionLift int64          `json:"is_competition_lift"`
	ParentLiftID      sql.NullString `json:"parent_lift_id"`
	UpdatedAt         string         `json:"updated_at"`
	ID                string         `json:"id"`
}

func (q *Queries) UpdateLift(ctx context.Context, arg UpdateLiftParams) error {
	_, err := q.db.ExecContext(ctx, updateLift,
		arg.Name,
		arg.Slug,
		arg.IsCompetitionLift,
		arg.ParentLiftID,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
