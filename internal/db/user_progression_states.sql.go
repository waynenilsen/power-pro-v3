// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user_progression_states.sql

package db

import (
	"context"
	"database/sql"
)

const createUserProgressionState = `-- name: CreateUserProgressionState :exec

INSERT INTO user_progression_states (id, user_id, lift_id, progression_id, current_stage, state_data, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
`

type CreateUserProgressionStateParams struct {
	ID            string         `json:"id"`
	UserID        string         `json:"user_id"`
	LiftID        string         `json:"lift_id"`
	ProgressionID string         `json:"progression_id"`
	CurrentStage  int64          `json:"current_stage"`
	StateData     sql.NullString `json:"state_data"`
}

// User Progression States Queries
// Used to track per-user, per-lift, per-progression state (e.g., current stage)
func (q *Queries) CreateUserProgressionState(ctx context.Context, arg CreateUserProgressionStateParams) error {
	_, err := q.db.ExecContext(ctx, createUserProgressionState,
		arg.ID,
		arg.UserID,
		arg.LiftID,
		arg.ProgressionID,
		arg.CurrentStage,
		arg.StateData,
	)
	return err
}

const deleteUserProgressionState = `-- name: DeleteUserProgressionState :exec
DELETE FROM user_progression_states
WHERE user_id = ? AND lift_id = ? AND progression_id = ?
`

type DeleteUserProgressionStateParams struct {
	UserID        string `json:"user_id"`
	LiftID        string `json:"lift_id"`
	ProgressionID string `json:"progression_id"`
}

func (q *Queries) DeleteUserProgressionState(ctx context.Context, arg DeleteUserProgressionStateParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserProgressionState, arg.UserID, arg.LiftID, arg.ProgressionID)
	return err
}

const getUserProgressionState = `-- name: GetUserProgressionState :one
SELECT id, user_id, lift_id, progression_id, current_stage, state_data, created_at, updated_at
FROM user_progression_states
WHERE user_id = ? AND lift_id = ? AND progression_id = ?
`

type GetUserProgressionStateParams struct {
	UserID        string `json:"user_id"`
	LiftID        string `json:"lift_id"`
	ProgressionID string `json:"progression_id"`
}

func (q *Queries) GetUserProgressionState(ctx context.Context, arg GetUserProgressionStateParams) (UserProgressionState, error) {
	row := q.db.QueryRowContext(ctx, getUserProgressionState, arg.UserID, arg.LiftID, arg.ProgressionID)
	var i UserProgressionState
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LiftID,
		&i.ProgressionID,
		&i.CurrentStage,
		&i.StateData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listUserProgressionStatesByProgression = `-- name: ListUserProgressionStatesByProgression :many
SELECT id, user_id, lift_id, progression_id, current_stage, state_data, created_at, updated_at
FROM user_progression_states
WHERE progression_id = ?
ORDER BY updated_at DESC
`

func (q *Queries) ListUserProgressionStatesByProgression(ctx context.Context, progressionID string) ([]UserProgressionState, error) {
	rows, err := q.db.QueryContext(ctx, listUserProgressionStatesByProgression, progressionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserProgressionState{}
	for rows.Next() {
		var i UserProgressionState
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LiftID,
			&i.ProgressionID,
			&i.CurrentStage,
			&i.StateData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserProgressionStatesByUser = `-- name: ListUserProgressionStatesByUser :many
SELECT id, user_id, lift_id, progression_id, current_stage, state_data, created_at, updated_at
FROM user_progression_states
WHERE user_id = ?
ORDER BY updated_at DESC
`

func (q *Queries) ListUserProgressionStatesByUser(ctx context.Context, userID string) ([]UserProgressionState, error) {
	rows, err := q.db.QueryContext(ctx, listUserProgressionStatesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserProgressionState{}
	for rows.Next() {
		var i UserProgressionState
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LiftID,
			&i.ProgressionID,
			&i.CurrentStage,
			&i.StateData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserProgressionStateStage = `-- name: UpdateUserProgressionStateStage :exec
UPDATE user_progression_states
SET current_stage = ?, updated_at = datetime('now')
WHERE user_id = ? AND lift_id = ? AND progression_id = ?
`

type UpdateUserProgressionStateStageParams struct {
	CurrentStage  int64  `json:"current_stage"`
	UserID        string `json:"user_id"`
	LiftID        string `json:"lift_id"`
	ProgressionID string `json:"progression_id"`
}

func (q *Queries) UpdateUserProgressionStateStage(ctx context.Context, arg UpdateUserProgressionStateStageParams) error {
	_, err := q.db.ExecContext(ctx, updateUserProgressionStateStage,
		arg.CurrentStage,
		arg.UserID,
		arg.LiftID,
		arg.ProgressionID,
	)
	return err
}

const upsertUserProgressionState = `-- name: UpsertUserProgressionState :exec
INSERT INTO user_progression_states (id, user_id, lift_id, progression_id, current_stage, state_data, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, datetime('now'), datetime('now'))
ON CONFLICT(user_id, lift_id, progression_id) DO UPDATE SET
    current_stage = excluded.current_stage,
    state_data = excluded.state_data,
    updated_at = datetime('now')
`

type UpsertUserProgressionStateParams struct {
	ID            string         `json:"id"`
	UserID        string         `json:"user_id"`
	LiftID        string         `json:"lift_id"`
	ProgressionID string         `json:"progression_id"`
	CurrentStage  int64          `json:"current_stage"`
	StateData     sql.NullString `json:"state_data"`
}

func (q *Queries) UpsertUserProgressionState(ctx context.Context, arg UpsertUserProgressionStateParams) error {
	_, err := q.db.ExecContext(ctx, upsertUserProgressionState,
		arg.ID,
		arg.UserID,
		arg.LiftID,
		arg.ProgressionID,
		arg.CurrentStage,
		arg.StateData,
	)
	return err
}
