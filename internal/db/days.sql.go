// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: days.sql

package db

import (
	"context"
	"database/sql"
)

const countDayPrescriptions = `-- name: CountDayPrescriptions :one
SELECT COUNT(*) FROM day_prescriptions WHERE day_id = ?
`

func (q *Queries) CountDayPrescriptions(ctx context.Context, dayID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDayPrescriptions, dayID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDays = `-- name: CountDays :one
SELECT COUNT(*) FROM days
`

func (q *Queries) CountDays(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDays)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countDaysFilteredByProgram = `-- name: CountDaysFilteredByProgram :one
SELECT COUNT(*) FROM days WHERE program_id = ?
`

func (q *Queries) CountDaysFilteredByProgram(ctx context.Context, programID sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDaysFilteredByProgram, programID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createDay = `-- name: CreateDay :exec
INSERT INTO days (id, name, slug, metadata, program_id, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateDayParams struct {
	ID        string         `json:"id"`
	Name      string         `json:"name"`
	Slug      string         `json:"slug"`
	Metadata  sql.NullString `json:"metadata"`
	ProgramID sql.NullString `json:"program_id"`
	CreatedAt string         `json:"created_at"`
	UpdatedAt string         `json:"updated_at"`
}

func (q *Queries) CreateDay(ctx context.Context, arg CreateDayParams) error {
	_, err := q.db.ExecContext(ctx, createDay,
		arg.ID,
		arg.Name,
		arg.Slug,
		arg.Metadata,
		arg.ProgramID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const createDayPrescription = `-- name: CreateDayPrescription :exec
INSERT INTO day_prescriptions (id, day_id, prescription_id, "order", created_at)
VALUES (?, ?, ?, ?, ?)
`

type CreateDayPrescriptionParams struct {
	ID             string `json:"id"`
	DayID          string `json:"day_id"`
	PrescriptionID string `json:"prescription_id"`
	Order          int64  `json:"order"`
	CreatedAt      string `json:"created_at"`
}

func (q *Queries) CreateDayPrescription(ctx context.Context, arg CreateDayPrescriptionParams) error {
	_, err := q.db.ExecContext(ctx, createDayPrescription,
		arg.ID,
		arg.DayID,
		arg.PrescriptionID,
		arg.Order,
		arg.CreatedAt,
	)
	return err
}

const dayIsUsedInWeeks = `-- name: DayIsUsedInWeeks :one
SELECT EXISTS(SELECT 1 FROM week_days WHERE day_id = ?) AS is_used
`

func (q *Queries) DayIsUsedInWeeks(ctx context.Context, dayID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, dayIsUsedInWeeks, dayID)
	var is_used int64
	err := row.Scan(&is_used)
	return is_used, err
}

const daySlugExists = `-- name: DaySlugExists :one
SELECT EXISTS(SELECT 1 FROM days WHERE slug = ? AND program_id = ? AND id != ?) AS slug_exists
`

type DaySlugExistsParams struct {
	Slug      string         `json:"slug"`
	ProgramID sql.NullString `json:"program_id"`
	ID        string         `json:"id"`
}

func (q *Queries) DaySlugExists(ctx context.Context, arg DaySlugExistsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, daySlugExists, arg.Slug, arg.ProgramID, arg.ID)
	var slug_exists int64
	err := row.Scan(&slug_exists)
	return slug_exists, err
}

const daySlugExistsForNew = `-- name: DaySlugExistsForNew :one
SELECT EXISTS(SELECT 1 FROM days WHERE slug = ? AND program_id = ?) AS slug_exists
`

type DaySlugExistsForNewParams struct {
	Slug      string         `json:"slug"`
	ProgramID sql.NullString `json:"program_id"`
}

func (q *Queries) DaySlugExistsForNew(ctx context.Context, arg DaySlugExistsForNewParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, daySlugExistsForNew, arg.Slug, arg.ProgramID)
	var slug_exists int64
	err := row.Scan(&slug_exists)
	return slug_exists, err
}

const daySlugExistsNullProgram = `-- name: DaySlugExistsNullProgram :one
SELECT EXISTS(SELECT 1 FROM days WHERE slug = ? AND program_id IS NULL AND id != ?) AS slug_exists
`

type DaySlugExistsNullProgramParams struct {
	Slug string `json:"slug"`
	ID   string `json:"id"`
}

func (q *Queries) DaySlugExistsNullProgram(ctx context.Context, arg DaySlugExistsNullProgramParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, daySlugExistsNullProgram, arg.Slug, arg.ID)
	var slug_exists int64
	err := row.Scan(&slug_exists)
	return slug_exists, err
}

const daySlugExistsNullProgramForNew = `-- name: DaySlugExistsNullProgramForNew :one
SELECT EXISTS(SELECT 1 FROM days WHERE slug = ? AND program_id IS NULL) AS slug_exists
`

func (q *Queries) DaySlugExistsNullProgramForNew(ctx context.Context, slug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, daySlugExistsNullProgramForNew, slug)
	var slug_exists int64
	err := row.Scan(&slug_exists)
	return slug_exists, err
}

const deleteDay = `-- name: DeleteDay :exec
DELETE FROM days WHERE id = ?
`

func (q *Queries) DeleteDay(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteDay, id)
	return err
}

const deleteDayPrescription = `-- name: DeleteDayPrescription :exec
DELETE FROM day_prescriptions WHERE id = ?
`

func (q *Queries) DeleteDayPrescription(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteDayPrescription, id)
	return err
}

const deleteDayPrescriptionByDayAndPrescription = `-- name: DeleteDayPrescriptionByDayAndPrescription :exec
DELETE FROM day_prescriptions WHERE day_id = ? AND prescription_id = ?
`

type DeleteDayPrescriptionByDayAndPrescriptionParams struct {
	DayID          string `json:"day_id"`
	PrescriptionID string `json:"prescription_id"`
}

func (q *Queries) DeleteDayPrescriptionByDayAndPrescription(ctx context.Context, arg DeleteDayPrescriptionByDayAndPrescriptionParams) error {
	_, err := q.db.ExecContext(ctx, deleteDayPrescriptionByDayAndPrescription, arg.DayID, arg.PrescriptionID)
	return err
}

const getDay = `-- name: GetDay :one
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
WHERE id = ?
`

func (q *Queries) GetDay(ctx context.Context, id string) (Day, error) {
	row := q.db.QueryRowContext(ctx, getDay, id)
	var i Day
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Metadata,
		&i.ProgramID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDayBySlug = `-- name: GetDayBySlug :one
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
WHERE slug = ? AND (program_id = ? OR (program_id IS NULL AND ? IS NULL))
`

type GetDayBySlugParams struct {
	Slug      string         `json:"slug"`
	ProgramID sql.NullString `json:"program_id"`
	Column3   interface{}    `json:"column_3"`
}

func (q *Queries) GetDayBySlug(ctx context.Context, arg GetDayBySlugParams) (Day, error) {
	row := q.db.QueryRowContext(ctx, getDayBySlug, arg.Slug, arg.ProgramID, arg.Column3)
	var i Day
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Metadata,
		&i.ProgramID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDayPrescription = `-- name: GetDayPrescription :one

SELECT id, day_id, prescription_id, "order", created_at
FROM day_prescriptions
WHERE id = ?
`

// Day Prescriptions queries
func (q *Queries) GetDayPrescription(ctx context.Context, id string) (DayPrescription, error) {
	row := q.db.QueryRowContext(ctx, getDayPrescription, id)
	var i DayPrescription
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.PrescriptionID,
		&i.Order,
		&i.CreatedAt,
	)
	return i, err
}

const getDayPrescriptionByDayAndPrescription = `-- name: GetDayPrescriptionByDayAndPrescription :one
SELECT id, day_id, prescription_id, "order", created_at
FROM day_prescriptions
WHERE day_id = ? AND prescription_id = ?
`

type GetDayPrescriptionByDayAndPrescriptionParams struct {
	DayID          string `json:"day_id"`
	PrescriptionID string `json:"prescription_id"`
}

func (q *Queries) GetDayPrescriptionByDayAndPrescription(ctx context.Context, arg GetDayPrescriptionByDayAndPrescriptionParams) (DayPrescription, error) {
	row := q.db.QueryRowContext(ctx, getDayPrescriptionByDayAndPrescription, arg.DayID, arg.PrescriptionID)
	var i DayPrescription
	err := row.Scan(
		&i.ID,
		&i.DayID,
		&i.PrescriptionID,
		&i.Order,
		&i.CreatedAt,
	)
	return i, err
}

const getMaxDayPrescriptionOrder = `-- name: GetMaxDayPrescriptionOrder :one
SELECT COALESCE(MAX("order"), -1) as max_order
FROM day_prescriptions
WHERE day_id = ?
`

func (q *Queries) GetMaxDayPrescriptionOrder(ctx context.Context, dayID string) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxDayPrescriptionOrder, dayID)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const listDayPrescriptions = `-- name: ListDayPrescriptions :many
SELECT dp.id, dp.day_id, dp.prescription_id, dp."order", dp.created_at
FROM day_prescriptions dp
WHERE dp.day_id = ?
ORDER BY dp."order" ASC
`

func (q *Queries) ListDayPrescriptions(ctx context.Context, dayID string) ([]DayPrescription, error) {
	rows, err := q.db.QueryContext(ctx, listDayPrescriptions, dayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DayPrescription{}
	for rows.Next() {
		var i DayPrescription
		if err := rows.Scan(
			&i.ID,
			&i.DayID,
			&i.PrescriptionID,
			&i.Order,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDaysByCreatedAtAsc = `-- name: ListDaysByCreatedAtAsc :many
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
ORDER BY created_at ASC
LIMIT ? OFFSET ?
`

type ListDaysByCreatedAtAscParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListDaysByCreatedAtAsc(ctx context.Context, arg ListDaysByCreatedAtAscParams) ([]Day, error) {
	rows, err := q.db.QueryContext(ctx, listDaysByCreatedAtAsc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Day{}
	for rows.Next() {
		var i Day
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Metadata,
			&i.ProgramID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDaysByCreatedAtDesc = `-- name: ListDaysByCreatedAtDesc :many
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListDaysByCreatedAtDescParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListDaysByCreatedAtDesc(ctx context.Context, arg ListDaysByCreatedAtDescParams) ([]Day, error) {
	rows, err := q.db.QueryContext(ctx, listDaysByCreatedAtDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Day{}
	for rows.Next() {
		var i Day
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Metadata,
			&i.ProgramID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDaysByNameAsc = `-- name: ListDaysByNameAsc :many
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListDaysByNameAscParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListDaysByNameAsc(ctx context.Context, arg ListDaysByNameAscParams) ([]Day, error) {
	rows, err := q.db.QueryContext(ctx, listDaysByNameAsc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Day{}
	for rows.Next() {
		var i Day
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Metadata,
			&i.ProgramID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDaysByNameDesc = `-- name: ListDaysByNameDesc :many
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
ORDER BY name DESC
LIMIT ? OFFSET ?
`

type ListDaysByNameDescParams struct {
	Limit  int64 `json:"limit"`
	Offset int64 `json:"offset"`
}

func (q *Queries) ListDaysByNameDesc(ctx context.Context, arg ListDaysByNameDescParams) ([]Day, error) {
	rows, err := q.db.QueryContext(ctx, listDaysByNameDesc, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Day{}
	for rows.Next() {
		var i Day
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Metadata,
			&i.ProgramID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDaysFilteredByProgramByCreatedAtAsc = `-- name: ListDaysFilteredByProgramByCreatedAtAsc :many
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
WHERE program_id = ?
ORDER BY created_at ASC
LIMIT ? OFFSET ?
`

type ListDaysFilteredByProgramByCreatedAtAscParams struct {
	ProgramID sql.NullString `json:"program_id"`
	Limit     int64          `json:"limit"`
	Offset    int64          `json:"offset"`
}

func (q *Queries) ListDaysFilteredByProgramByCreatedAtAsc(ctx context.Context, arg ListDaysFilteredByProgramByCreatedAtAscParams) ([]Day, error) {
	rows, err := q.db.QueryContext(ctx, listDaysFilteredByProgramByCreatedAtAsc, arg.ProgramID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Day{}
	for rows.Next() {
		var i Day
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Metadata,
			&i.ProgramID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDaysFilteredByProgramByCreatedAtDesc = `-- name: ListDaysFilteredByProgramByCreatedAtDesc :many
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
WHERE program_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListDaysFilteredByProgramByCreatedAtDescParams struct {
	ProgramID sql.NullString `json:"program_id"`
	Limit     int64          `json:"limit"`
	Offset    int64          `json:"offset"`
}

func (q *Queries) ListDaysFilteredByProgramByCreatedAtDesc(ctx context.Context, arg ListDaysFilteredByProgramByCreatedAtDescParams) ([]Day, error) {
	rows, err := q.db.QueryContext(ctx, listDaysFilteredByProgramByCreatedAtDesc, arg.ProgramID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Day{}
	for rows.Next() {
		var i Day
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Metadata,
			&i.ProgramID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDaysFilteredByProgramByNameAsc = `-- name: ListDaysFilteredByProgramByNameAsc :many
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
WHERE program_id = ?
ORDER BY name ASC
LIMIT ? OFFSET ?
`

type ListDaysFilteredByProgramByNameAscParams struct {
	ProgramID sql.NullString `json:"program_id"`
	Limit     int64          `json:"limit"`
	Offset    int64          `json:"offset"`
}

func (q *Queries) ListDaysFilteredByProgramByNameAsc(ctx context.Context, arg ListDaysFilteredByProgramByNameAscParams) ([]Day, error) {
	rows, err := q.db.QueryContext(ctx, listDaysFilteredByProgramByNameAsc, arg.ProgramID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Day{}
	for rows.Next() {
		var i Day
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Metadata,
			&i.ProgramID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDaysFilteredByProgramByNameDesc = `-- name: ListDaysFilteredByProgramByNameDesc :many
SELECT id, name, slug, metadata, program_id, created_at, updated_at
FROM days
WHERE program_id = ?
ORDER BY name DESC
LIMIT ? OFFSET ?
`

type ListDaysFilteredByProgramByNameDescParams struct {
	ProgramID sql.NullString `json:"program_id"`
	Limit     int64          `json:"limit"`
	Offset    int64          `json:"offset"`
}

func (q *Queries) ListDaysFilteredByProgramByNameDesc(ctx context.Context, arg ListDaysFilteredByProgramByNameDescParams) ([]Day, error) {
	rows, err := q.db.QueryContext(ctx, listDaysFilteredByProgramByNameDesc, arg.ProgramID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Day{}
	for rows.Next() {
		var i Day
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Metadata,
			&i.ProgramID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDay = `-- name: UpdateDay :exec
UPDATE days
SET name = ?, slug = ?, metadata = ?, program_id = ?, updated_at = ?
WHERE id = ?
`

type UpdateDayParams struct {
	Name      string         `json:"name"`
	Slug      string         `json:"slug"`
	Metadata  sql.NullString `json:"metadata"`
	ProgramID sql.NullString `json:"program_id"`
	UpdatedAt string         `json:"updated_at"`
	ID        string         `json:"id"`
}

func (q *Queries) UpdateDay(ctx context.Context, arg UpdateDayParams) error {
	_, err := q.db.ExecContext(ctx, updateDay,
		arg.Name,
		arg.Slug,
		arg.Metadata,
		arg.ProgramID,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const updateDayPrescriptionOrder = `-- name: UpdateDayPrescriptionOrder :exec
UPDATE day_prescriptions
SET "order" = ?
WHERE id = ?
`

type UpdateDayPrescriptionOrderParams struct {
	Order int64  `json:"order"`
	ID    string `json:"id"`
}

func (q *Queries) UpdateDayPrescriptionOrder(ctx context.Context, arg UpdateDayPrescriptionOrderParams) error {
	_, err := q.db.ExecContext(ctx, updateDayPrescriptionOrder, arg.Order, arg.ID)
	return err
}
