// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workouts.sql

package db

import (
	"context"
	"database/sql"
)

const countDaysInWeek = `-- name: CountDaysInWeek :one
SELECT COUNT(*) FROM week_days WHERE week_id = ?
`

func (q *Queries) CountDaysInWeek(ctx context.Context, weekID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDaysInWeek, weekID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDayByIndexInWeek = `-- name: GetDayByIndexInWeek :one
SELECT d.id, d.name, d.slug, d.metadata, d.program_id, d.created_at, d.updated_at
FROM days d
JOIN week_days wd ON d.id = wd.day_id
WHERE wd.week_id = ?
ORDER BY
    CASE wd.day_of_week
        WHEN 'MONDAY' THEN 1
        WHEN 'TUESDAY' THEN 2
        WHEN 'WEDNESDAY' THEN 3
        WHEN 'THURSDAY' THEN 4
        WHEN 'FRIDAY' THEN 5
        WHEN 'SATURDAY' THEN 6
        WHEN 'SUNDAY' THEN 7
    END ASC
LIMIT 1 OFFSET ?
`

type GetDayByIndexInWeekParams struct {
	WeekID string `json:"week_id"`
	Offset int64  `json:"offset"`
}

func (q *Queries) GetDayByIndexInWeek(ctx context.Context, arg GetDayByIndexInWeekParams) (Day, error) {
	row := q.db.QueryRowContext(ctx, getDayByIndexInWeek, arg.WeekID, arg.Offset)
	var i Day
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Metadata,
		&i.ProgramID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDayBySlugAndWeek = `-- name: GetDayBySlugAndWeek :one
SELECT d.id, d.name, d.slug, d.metadata, d.program_id, d.created_at, d.updated_at
FROM days d
JOIN week_days wd ON d.id = wd.day_id
WHERE d.slug = ? AND wd.week_id = ?
`

type GetDayBySlugAndWeekParams struct {
	Slug   string `json:"slug"`
	WeekID string `json:"week_id"`
}

func (q *Queries) GetDayBySlugAndWeek(ctx context.Context, arg GetDayBySlugAndWeekParams) (Day, error) {
	row := q.db.QueryRowContext(ctx, getDayBySlugAndWeek, arg.Slug, arg.WeekID)
	var i Day
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Metadata,
		&i.ProgramID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getDaysForWeek = `-- name: GetDaysForWeek :many
SELECT d.id, d.name, d.slug, d.metadata, d.program_id, d.created_at, d.updated_at,
       wd.day_of_week
FROM days d
JOIN week_days wd ON d.id = wd.day_id
WHERE wd.week_id = ?
ORDER BY
    CASE wd.day_of_week
        WHEN 'MONDAY' THEN 1
        WHEN 'TUESDAY' THEN 2
        WHEN 'WEDNESDAY' THEN 3
        WHEN 'THURSDAY' THEN 4
        WHEN 'FRIDAY' THEN 5
        WHEN 'SATURDAY' THEN 6
        WHEN 'SUNDAY' THEN 7
    END ASC
`

type GetDaysForWeekRow struct {
	ID        string         `json:"id"`
	Name      string         `json:"name"`
	Slug      string         `json:"slug"`
	Metadata  sql.NullString `json:"metadata"`
	ProgramID sql.NullString `json:"program_id"`
	CreatedAt string         `json:"created_at"`
	UpdatedAt string         `json:"updated_at"`
	DayOfWeek string         `json:"day_of_week"`
}

func (q *Queries) GetDaysForWeek(ctx context.Context, weekID string) ([]GetDaysForWeekRow, error) {
	rows, err := q.db.QueryContext(ctx, getDaysForWeek, weekID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetDaysForWeekRow{}
	for rows.Next() {
		var i GetDaysForWeekRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Metadata,
			&i.ProgramID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DayOfWeek,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEnrollmentForWorkout = `-- name: GetEnrollmentForWorkout :one
SELECT
    ups.id,
    ups.user_id,
    ups.program_id,
    ups.current_week,
    ups.current_cycle_iteration,
    ups.current_day_index,
    p.name AS program_name,
    p.slug AS program_slug,
    p.cycle_id,
    p.weekly_lookup_id,
    p.daily_lookup_id,
    p.default_rounding,
    c.length_weeks AS cycle_length_weeks
FROM user_program_states ups
JOIN programs p ON ups.program_id = p.id
JOIN cycles c ON p.cycle_id = c.id
WHERE ups.user_id = ?
`

type GetEnrollmentForWorkoutRow struct {
	ID                    string          `json:"id"`
	UserID                string          `json:"user_id"`
	ProgramID             string          `json:"program_id"`
	CurrentWeek           int64           `json:"current_week"`
	CurrentCycleIteration int64           `json:"current_cycle_iteration"`
	CurrentDayIndex       sql.NullInt64   `json:"current_day_index"`
	ProgramName           string          `json:"program_name"`
	ProgramSlug           string          `json:"program_slug"`
	CycleID               string          `json:"cycle_id"`
	WeeklyLookupID        sql.NullString  `json:"weekly_lookup_id"`
	DailyLookupID         sql.NullString  `json:"daily_lookup_id"`
	DefaultRounding       sql.NullFloat64 `json:"default_rounding"`
	CycleLengthWeeks      int64           `json:"cycle_length_weeks"`
}

func (q *Queries) GetEnrollmentForWorkout(ctx context.Context, userID string) (GetEnrollmentForWorkoutRow, error) {
	row := q.db.QueryRowContext(ctx, getEnrollmentForWorkout, userID)
	var i GetEnrollmentForWorkoutRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ProgramID,
		&i.CurrentWeek,
		&i.CurrentCycleIteration,
		&i.CurrentDayIndex,
		&i.ProgramName,
		&i.ProgramSlug,
		&i.CycleID,
		&i.WeeklyLookupID,
		&i.DailyLookupID,
		&i.DefaultRounding,
		&i.CycleLengthWeeks,
	)
	return i, err
}

const getPrescriptionsForDay = `-- name: GetPrescriptionsForDay :many
SELECT p.id, p.lift_id, p.load_strategy, p.set_scheme, p."order", p.notes, p.rest_seconds, p.created_at, p.updated_at
FROM prescriptions p
JOIN day_prescriptions dp ON p.id = dp.prescription_id
WHERE dp.day_id = ?
ORDER BY dp."order" ASC
`

func (q *Queries) GetPrescriptionsForDay(ctx context.Context, dayID string) ([]Prescription, error) {
	rows, err := q.db.QueryContext(ctx, getPrescriptionsForDay, dayID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Prescription{}
	for rows.Next() {
		var i Prescription
		if err := rows.Scan(
			&i.ID,
			&i.LiftID,
			&i.LoadStrategy,
			&i.SetScheme,
			&i.Order,
			&i.Notes,
			&i.RestSeconds,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProgramWithCycle = `-- name: GetProgramWithCycle :one
SELECT
    p.id AS program_id,
    p.name AS program_name,
    p.slug AS program_slug,
    p.description AS program_description,
    p.cycle_id,
    p.weekly_lookup_id,
    p.daily_lookup_id,
    p.default_rounding,
    c.length_weeks AS cycle_length_weeks
FROM programs p
JOIN cycles c ON p.cycle_id = c.id
WHERE p.id = ?
`

type GetProgramWithCycleRow struct {
	ProgramID          string          `json:"program_id"`
	ProgramName        string          `json:"program_name"`
	ProgramSlug        string          `json:"program_slug"`
	ProgramDescription sql.NullString  `json:"program_description"`
	CycleID            string          `json:"cycle_id"`
	WeeklyLookupID     sql.NullString  `json:"weekly_lookup_id"`
	DailyLookupID      sql.NullString  `json:"daily_lookup_id"`
	DefaultRounding    sql.NullFloat64 `json:"default_rounding"`
	CycleLengthWeeks   int64           `json:"cycle_length_weeks"`
}

func (q *Queries) GetProgramWithCycle(ctx context.Context, id string) (GetProgramWithCycleRow, error) {
	row := q.db.QueryRowContext(ctx, getProgramWithCycle, id)
	var i GetProgramWithCycleRow
	err := row.Scan(
		&i.ProgramID,
		&i.ProgramName,
		&i.ProgramSlug,
		&i.ProgramDescription,
		&i.CycleID,
		&i.WeeklyLookupID,
		&i.DailyLookupID,
		&i.DefaultRounding,
		&i.CycleLengthWeeks,
	)
	return i, err
}

const getWeekByNumberAndCycle = `-- name: GetWeekByNumberAndCycle :one

SELECT id, week_number, variant, cycle_id, created_at, updated_at
FROM weeks
WHERE cycle_id = ? AND week_number = ?
`

type GetWeekByNumberAndCycleParams struct {
	CycleID    string `json:"cycle_id"`
	WeekNumber int64  `json:"week_number"`
}

// Workout Generation Queries
// These queries support the workout generation API endpoint.
func (q *Queries) GetWeekByNumberAndCycle(ctx context.Context, arg GetWeekByNumberAndCycleParams) (Week, error) {
	row := q.db.QueryRowContext(ctx, getWeekByNumberAndCycle, arg.CycleID, arg.WeekNumber)
	var i Week
	err := row.Scan(
		&i.ID,
		&i.WeekNumber,
		&i.Variant,
		&i.CycleID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
