// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: logged_sets.sql

package db

import (
	"context"
)

const countLoggedSetsByUser = `-- name: CountLoggedSetsByUser :one
SELECT COUNT(*) FROM logged_sets WHERE user_id = ?
`

func (q *Queries) CountLoggedSetsByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLoggedSetsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createLoggedSet = `-- name: CreateLoggedSet :exec
INSERT INTO logged_sets (id, user_id, session_id, prescription_id, lift_id, set_number, weight, target_reps, reps_performed, is_amrap, created_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateLoggedSetParams struct {
	ID             string  `json:"id"`
	UserID         string  `json:"user_id"`
	SessionID      string  `json:"session_id"`
	PrescriptionID string  `json:"prescription_id"`
	LiftID         string  `json:"lift_id"`
	SetNumber      int64   `json:"set_number"`
	Weight         float64 `json:"weight"`
	TargetReps     int64   `json:"target_reps"`
	RepsPerformed  int64   `json:"reps_performed"`
	IsAmrap        bool    `json:"is_amrap"`
	CreatedAt      string  `json:"created_at"`
}

func (q *Queries) CreateLoggedSet(ctx context.Context, arg CreateLoggedSetParams) error {
	_, err := q.db.ExecContext(ctx, createLoggedSet,
		arg.ID,
		arg.UserID,
		arg.SessionID,
		arg.PrescriptionID,
		arg.LiftID,
		arg.SetNumber,
		arg.Weight,
		arg.TargetReps,
		arg.RepsPerformed,
		arg.IsAmrap,
		arg.CreatedAt,
	)
	return err
}

const deleteLoggedSet = `-- name: DeleteLoggedSet :exec
DELETE FROM logged_sets WHERE id = ?
`

func (q *Queries) DeleteLoggedSet(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteLoggedSet, id)
	return err
}

const deleteLoggedSetsBySession = `-- name: DeleteLoggedSetsBySession :exec
DELETE FROM logged_sets WHERE session_id = ?
`

func (q *Queries) DeleteLoggedSetsBySession(ctx context.Context, sessionID string) error {
	_, err := q.db.ExecContext(ctx, deleteLoggedSetsBySession, sessionID)
	return err
}

const getLatestAMRAPForLift = `-- name: GetLatestAMRAPForLift :one
SELECT id, user_id, session_id, prescription_id, lift_id, set_number, weight, target_reps, reps_performed, is_amrap, created_at
FROM logged_sets
WHERE user_id = ? AND lift_id = ? AND is_amrap = TRUE
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestAMRAPForLiftParams struct {
	UserID string `json:"user_id"`
	LiftID string `json:"lift_id"`
}

func (q *Queries) GetLatestAMRAPForLift(ctx context.Context, arg GetLatestAMRAPForLiftParams) (LoggedSet, error) {
	row := q.db.QueryRowContext(ctx, getLatestAMRAPForLift, arg.UserID, arg.LiftID)
	var i LoggedSet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.PrescriptionID,
		&i.LiftID,
		&i.SetNumber,
		&i.Weight,
		&i.TargetReps,
		&i.RepsPerformed,
		&i.IsAmrap,
		&i.CreatedAt,
	)
	return i, err
}

const getLoggedSet = `-- name: GetLoggedSet :one
SELECT id, user_id, session_id, prescription_id, lift_id, set_number, weight, target_reps, reps_performed, is_amrap, created_at
FROM logged_sets
WHERE id = ?
`

func (q *Queries) GetLoggedSet(ctx context.Context, id string) (LoggedSet, error) {
	row := q.db.QueryRowContext(ctx, getLoggedSet, id)
	var i LoggedSet
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionID,
		&i.PrescriptionID,
		&i.LiftID,
		&i.SetNumber,
		&i.Weight,
		&i.TargetReps,
		&i.RepsPerformed,
		&i.IsAmrap,
		&i.CreatedAt,
	)
	return i, err
}

const listLoggedSetsBySession = `-- name: ListLoggedSetsBySession :many
SELECT id, user_id, session_id, prescription_id, lift_id, set_number, weight, target_reps, reps_performed, is_amrap, created_at
FROM logged_sets
WHERE session_id = ?
ORDER BY created_at ASC, set_number ASC
`

func (q *Queries) ListLoggedSetsBySession(ctx context.Context, sessionID string) ([]LoggedSet, error) {
	rows, err := q.db.QueryContext(ctx, listLoggedSetsBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoggedSet{}
	for rows.Next() {
		var i LoggedSet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.PrescriptionID,
			&i.LiftID,
			&i.SetNumber,
			&i.Weight,
			&i.TargetReps,
			&i.RepsPerformed,
			&i.IsAmrap,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoggedSetsByUser = `-- name: ListLoggedSetsByUser :many
SELECT id, user_id, session_id, prescription_id, lift_id, set_number, weight, target_reps, reps_performed, is_amrap, created_at
FROM logged_sets
WHERE user_id = ?
ORDER BY created_at DESC
LIMIT ? OFFSET ?
`

type ListLoggedSetsByUserParams struct {
	UserID string `json:"user_id"`
	Limit  int64  `json:"limit"`
	Offset int64  `json:"offset"`
}

func (q *Queries) ListLoggedSetsByUser(ctx context.Context, arg ListLoggedSetsByUserParams) ([]LoggedSet, error) {
	rows, err := q.db.QueryContext(ctx, listLoggedSetsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LoggedSet{}
	for rows.Next() {
		var i LoggedSet
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionID,
			&i.PrescriptionID,
			&i.LiftID,
			&i.SetNumber,
			&i.Weight,
			&i.TargetReps,
			&i.RepsPerformed,
			&i.IsAmrap,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
