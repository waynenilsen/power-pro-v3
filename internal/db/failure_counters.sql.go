// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: failure_counters.sql

package db

import (
	"context"
	"database/sql"
)

const countFailureCountersByUser = `-- name: CountFailureCountersByUser :one
SELECT COUNT(*) FROM failure_counters WHERE user_id = ?
`

func (q *Queries) CountFailureCountersByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countFailureCountersByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFailureCounter = `-- name: CreateFailureCounter :exec
INSERT INTO failure_counters (id, user_id, lift_id, progression_id, consecutive_failures, last_failure_at, last_success_at, created_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateFailureCounterParams struct {
	ID                  string         `json:"id"`
	UserID              string         `json:"user_id"`
	LiftID              string         `json:"lift_id"`
	ProgressionID       string         `json:"progression_id"`
	ConsecutiveFailures int64          `json:"consecutive_failures"`
	LastFailureAt       sql.NullString `json:"last_failure_at"`
	LastSuccessAt       sql.NullString `json:"last_success_at"`
	CreatedAt           string         `json:"created_at"`
	UpdatedAt           string         `json:"updated_at"`
}

func (q *Queries) CreateFailureCounter(ctx context.Context, arg CreateFailureCounterParams) error {
	_, err := q.db.ExecContext(ctx, createFailureCounter,
		arg.ID,
		arg.UserID,
		arg.LiftID,
		arg.ProgressionID,
		arg.ConsecutiveFailures,
		arg.LastFailureAt,
		arg.LastSuccessAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const deleteFailureCounter = `-- name: DeleteFailureCounter :exec
DELETE FROM failure_counters WHERE id = ?
`

func (q *Queries) DeleteFailureCounter(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteFailureCounter, id)
	return err
}

const deleteFailureCounterByKey = `-- name: DeleteFailureCounterByKey :exec
DELETE FROM failure_counters WHERE user_id = ? AND lift_id = ? AND progression_id = ?
`

type DeleteFailureCounterByKeyParams struct {
	UserID        string `json:"user_id"`
	LiftID        string `json:"lift_id"`
	ProgressionID string `json:"progression_id"`
}

func (q *Queries) DeleteFailureCounterByKey(ctx context.Context, arg DeleteFailureCounterByKeyParams) error {
	_, err := q.db.ExecContext(ctx, deleteFailureCounterByKey, arg.UserID, arg.LiftID, arg.ProgressionID)
	return err
}

const getFailureCounter = `-- name: GetFailureCounter :one
SELECT id, user_id, lift_id, progression_id, consecutive_failures, last_failure_at, last_success_at, created_at, updated_at
FROM failure_counters
WHERE id = ?
`

func (q *Queries) GetFailureCounter(ctx context.Context, id string) (FailureCounter, error) {
	row := q.db.QueryRowContext(ctx, getFailureCounter, id)
	var i FailureCounter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LiftID,
		&i.ProgressionID,
		&i.ConsecutiveFailures,
		&i.LastFailureAt,
		&i.LastSuccessAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getFailureCounterByKey = `-- name: GetFailureCounterByKey :one
SELECT id, user_id, lift_id, progression_id, consecutive_failures, last_failure_at, last_success_at, created_at, updated_at
FROM failure_counters
WHERE user_id = ? AND lift_id = ? AND progression_id = ?
`

type GetFailureCounterByKeyParams struct {
	UserID        string `json:"user_id"`
	LiftID        string `json:"lift_id"`
	ProgressionID string `json:"progression_id"`
}

func (q *Queries) GetFailureCounterByKey(ctx context.Context, arg GetFailureCounterByKeyParams) (FailureCounter, error) {
	row := q.db.QueryRowContext(ctx, getFailureCounterByKey, arg.UserID, arg.LiftID, arg.ProgressionID)
	var i FailureCounter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.LiftID,
		&i.ProgressionID,
		&i.ConsecutiveFailures,
		&i.LastFailureAt,
		&i.LastSuccessAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const incrementFailureCounter = `-- name: IncrementFailureCounter :exec
UPDATE failure_counters
SET consecutive_failures = consecutive_failures + 1,
    last_failure_at = ?,
    updated_at = ?
WHERE user_id = ? AND lift_id = ? AND progression_id = ?
`

type IncrementFailureCounterParams struct {
	LastFailureAt sql.NullString `json:"last_failure_at"`
	UpdatedAt     string         `json:"updated_at"`
	UserID        string         `json:"user_id"`
	LiftID        string         `json:"lift_id"`
	ProgressionID string         `json:"progression_id"`
}

func (q *Queries) IncrementFailureCounter(ctx context.Context, arg IncrementFailureCounterParams) error {
	_, err := q.db.ExecContext(ctx, incrementFailureCounter,
		arg.LastFailureAt,
		arg.UpdatedAt,
		arg.UserID,
		arg.LiftID,
		arg.ProgressionID,
	)
	return err
}

const listFailureCountersByProgression = `-- name: ListFailureCountersByProgression :many
SELECT id, user_id, lift_id, progression_id, consecutive_failures, last_failure_at, last_success_at, created_at, updated_at
FROM failure_counters
WHERE progression_id = ?
ORDER BY updated_at DESC
`

func (q *Queries) ListFailureCountersByProgression(ctx context.Context, progressionID string) ([]FailureCounter, error) {
	rows, err := q.db.QueryContext(ctx, listFailureCountersByProgression, progressionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailureCounter{}
	for rows.Next() {
		var i FailureCounter
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LiftID,
			&i.ProgressionID,
			&i.ConsecutiveFailures,
			&i.LastFailureAt,
			&i.LastSuccessAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailureCountersByUser = `-- name: ListFailureCountersByUser :many
SELECT id, user_id, lift_id, progression_id, consecutive_failures, last_failure_at, last_success_at, created_at, updated_at
FROM failure_counters
WHERE user_id = ?
ORDER BY updated_at DESC
`

func (q *Queries) ListFailureCountersByUser(ctx context.Context, userID string) ([]FailureCounter, error) {
	rows, err := q.db.QueryContext(ctx, listFailureCountersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailureCounter{}
	for rows.Next() {
		var i FailureCounter
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LiftID,
			&i.ProgressionID,
			&i.ConsecutiveFailures,
			&i.LastFailureAt,
			&i.LastSuccessAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailureCountersByUserAndLift = `-- name: ListFailureCountersByUserAndLift :many
SELECT id, user_id, lift_id, progression_id, consecutive_failures, last_failure_at, last_success_at, created_at, updated_at
FROM failure_counters
WHERE user_id = ? AND lift_id = ?
ORDER BY updated_at DESC
`

type ListFailureCountersByUserAndLiftParams struct {
	UserID string `json:"user_id"`
	LiftID string `json:"lift_id"`
}

func (q *Queries) ListFailureCountersByUserAndLift(ctx context.Context, arg ListFailureCountersByUserAndLiftParams) ([]FailureCounter, error) {
	rows, err := q.db.QueryContext(ctx, listFailureCountersByUserAndLift, arg.UserID, arg.LiftID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FailureCounter{}
	for rows.Next() {
		var i FailureCounter
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.LiftID,
			&i.ProgressionID,
			&i.ConsecutiveFailures,
			&i.LastFailureAt,
			&i.LastSuccessAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const resetFailureCounter = `-- name: ResetFailureCounter :exec
UPDATE failure_counters
SET consecutive_failures = 0,
    last_success_at = ?,
    updated_at = ?
WHERE user_id = ? AND lift_id = ? AND progression_id = ?
`

type ResetFailureCounterParams struct {
	LastSuccessAt sql.NullString `json:"last_success_at"`
	UpdatedAt     string         `json:"updated_at"`
	UserID        string         `json:"user_id"`
	LiftID        string         `json:"lift_id"`
	ProgressionID string         `json:"progression_id"`
}

func (q *Queries) ResetFailureCounter(ctx context.Context, arg ResetFailureCounterParams) error {
	_, err := q.db.ExecContext(ctx, resetFailureCounter,
		arg.LastSuccessAt,
		arg.UpdatedAt,
		arg.UserID,
		arg.LiftID,
		arg.ProgressionID,
	)
	return err
}

const updateFailureCounter = `-- name: UpdateFailureCounter :exec
UPDATE failure_counters
SET consecutive_failures = ?,
    last_failure_at = ?,
    last_success_at = ?,
    updated_at = ?
WHERE id = ?
`

type UpdateFailureCounterParams struct {
	ConsecutiveFailures int64          `json:"consecutive_failures"`
	LastFailureAt       sql.NullString `json:"last_failure_at"`
	LastSuccessAt       sql.NullString `json:"last_success_at"`
	UpdatedAt           string         `json:"updated_at"`
	ID                  string         `json:"id"`
}

func (q *Queries) UpdateFailureCounter(ctx context.Context, arg UpdateFailureCounterParams) error {
	_, err := q.db.ExecContext(ctx, updateFailureCounter,
		arg.ConsecutiveFailures,
		arg.LastFailureAt,
		arg.LastSuccessAt,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}

const upsertFailureCounterOnFailure = `-- name: UpsertFailureCounterOnFailure :exec
INSERT INTO failure_counters (id, user_id, lift_id, progression_id, consecutive_failures, last_failure_at, last_success_at, created_at, updated_at)
VALUES (?, ?, ?, ?, 1, ?, NULL, ?, ?)
ON CONFLICT(user_id, lift_id, progression_id) DO UPDATE SET
    consecutive_failures = consecutive_failures + 1,
    last_failure_at = excluded.last_failure_at,
    updated_at = excluded.updated_at
`

type UpsertFailureCounterOnFailureParams struct {
	ID            string         `json:"id"`
	UserID        string         `json:"user_id"`
	LiftID        string         `json:"lift_id"`
	ProgressionID string         `json:"progression_id"`
	LastFailureAt sql.NullString `json:"last_failure_at"`
	CreatedAt     string         `json:"created_at"`
	UpdatedAt     string         `json:"updated_at"`
}

func (q *Queries) UpsertFailureCounterOnFailure(ctx context.Context, arg UpsertFailureCounterOnFailureParams) error {
	_, err := q.db.ExecContext(ctx, upsertFailureCounterOnFailure,
		arg.ID,
		arg.UserID,
		arg.LiftID,
		arg.ProgressionID,
		arg.LastFailureAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const upsertFailureCounterOnSuccess = `-- name: UpsertFailureCounterOnSuccess :exec
INSERT INTO failure_counters (id, user_id, lift_id, progression_id, consecutive_failures, last_failure_at, last_success_at, created_at, updated_at)
VALUES (?, ?, ?, ?, 0, NULL, ?, ?, ?)
ON CONFLICT(user_id, lift_id, progression_id) DO UPDATE SET
    consecutive_failures = 0,
    last_success_at = excluded.last_success_at,
    updated_at = excluded.updated_at
`

type UpsertFailureCounterOnSuccessParams struct {
	ID            string         `json:"id"`
	UserID        string         `json:"user_id"`
	LiftID        string         `json:"lift_id"`
	ProgressionID string         `json:"progression_id"`
	LastSuccessAt sql.NullString `json:"last_success_at"`
	CreatedAt     string         `json:"created_at"`
	UpdatedAt     string         `json:"updated_at"`
}

func (q *Queries) UpsertFailureCounterOnSuccess(ctx context.Context, arg UpsertFailureCounterOnSuccessParams) error {
	_, err := q.db.ExecContext(ctx, upsertFailureCounterOnSuccess,
		arg.ID,
		arg.UserID,
		arg.LiftID,
		arg.ProgressionID,
		arg.LastSuccessAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}
