// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dashboard.sql

package db

import (
	"context"
	"database/sql"
)

const countLoggedSetsBySession = `-- name: CountLoggedSetsBySession :one
SELECT COUNT(*) FROM logged_sets WHERE session_id = ?
`

// Count logged sets for a session
func (q *Queries) CountLoggedSetsBySession(ctx context.Context, sessionID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countLoggedSetsBySession, sessionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getCurrentMaxesByUser = `-- name: GetCurrentMaxesByUser :many
SELECT
    id,
    lift_id,
    lift_name,
    type,
    value,
    effective_date
FROM (
    SELECT
        lm.id,
        lm.lift_id,
        l.name AS lift_name,
        lm.type,
        lm.value,
        lm.effective_date,
        ROW_NUMBER() OVER (
            PARTITION BY lm.lift_id
            ORDER BY
                lm.effective_date DESC,
                CASE lm.type WHEN 'TRAINING_MAX' THEN 0 ELSE 1 END ASC,
                lm.created_at DESC
        ) AS rn
    FROM lift_maxes lm
    JOIN lifts l ON lm.lift_id = l.id
    WHERE lm.user_id = ?
)
WHERE rn = 1
ORDER BY lift_name ASC
`

type GetCurrentMaxesByUserRow struct {
	ID            string  `json:"id"`
	LiftID        string  `json:"lift_id"`
	LiftName      string  `json:"lift_name"`
	Type          string  `json:"type"`
	Value         float64 `json:"value"`
	EffectiveDate string  `json:"effective_date"`
}

// Get the most recent max for each lift a user has recorded.
//
// LiftMaxHandler auto-creates TRAINING_MAX entries with the same effective_date
// as the corresponding ONE_RM. In that case, prefer returning TRAINING_MAX for
// dashboard display.
func (q *Queries) GetCurrentMaxesByUser(ctx context.Context, userID string) ([]GetCurrentMaxesByUserRow, error) {
	rows, err := q.db.QueryContext(ctx, getCurrentMaxesByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCurrentMaxesByUserRow{}
	for rows.Next() {
		var i GetCurrentMaxesByUserRow
		if err := rows.Scan(
			&i.ID,
			&i.LiftID,
			&i.LiftName,
			&i.Type,
			&i.Value,
			&i.EffectiveDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDayExerciseAndSetCounts = `-- name: GetDayExerciseAndSetCounts :one
SELECT
    COUNT(DISTINCT pr.lift_id) AS exercise_count,
    COALESCE(SUM(
        CASE
            WHEN pr.set_scheme IN ('fixed', 'greyskull') THEN 3
            WHEN pr.set_scheme = 'ramp' THEN 5
            WHEN pr.set_scheme = 'fatigue_drop' THEN 3
            WHEN pr.set_scheme = 'mrs' THEN 4
            WHEN pr.set_scheme = 'total_reps' THEN 5
            WHEN pr.set_scheme = 'amrap' THEN 1
            ELSE 3
        END
    ), 0) AS total_sets
FROM day_prescriptions dp
JOIN prescriptions pr ON dp.prescription_id = pr.id
WHERE dp.day_id = ?
`

type GetDayExerciseAndSetCountsRow struct {
	ExerciseCount int64       `json:"exercise_count"`
	TotalSets     interface{} `json:"total_sets"`
}

// Count distinct exercises and estimate total sets for a day
// Note: set_scheme stores the scheme type in the prescriptions table
func (q *Queries) GetDayExerciseAndSetCounts(ctx context.Context, dayID string) (GetDayExerciseAndSetCountsRow, error) {
	row := q.db.QueryRowContext(ctx, getDayExerciseAndSetCounts, dayID)
	var i GetDayExerciseAndSetCountsRow
	err := row.Scan(&i.ExerciseCount, &i.TotalSets)
	return i, err
}

const getDayForWeekPosition = `-- name: GetDayForWeekPosition :one
SELECT d.id, d.name, d.slug
FROM days d
JOIN week_days wd ON d.id = wd.day_id
JOIN weeks w ON wd.week_id = w.id
JOIN cycles c ON w.cycle_id = c.id
JOIN programs p ON p.cycle_id = c.id
WHERE p.id = ? AND w.week_number = ?
ORDER BY
    CASE wd.day_of_week
        WHEN 'MONDAY' THEN 1
        WHEN 'TUESDAY' THEN 2
        WHEN 'WEDNESDAY' THEN 3
        WHEN 'THURSDAY' THEN 4
        WHEN 'FRIDAY' THEN 5
        WHEN 'SATURDAY' THEN 6
        WHEN 'SUNDAY' THEN 7
    END ASC
LIMIT 1 OFFSET ?
`

type GetDayForWeekPositionParams struct {
	ID         string `json:"id"`
	WeekNumber int64  `json:"week_number"`
	Offset     int64  `json:"offset"`
}

type GetDayForWeekPositionRow struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// Get the day at a specific position in a week for a program
// Uses day_index as an offset into the ordered days by day_of_week
func (q *Queries) GetDayForWeekPosition(ctx context.Context, arg GetDayForWeekPositionParams) (GetDayForWeekPositionRow, error) {
	row := q.db.QueryRowContext(ctx, getDayForWeekPosition, arg.ID, arg.WeekNumber, arg.Offset)
	var i GetDayForWeekPositionRow
	err := row.Scan(&i.ID, &i.Name, &i.Slug)
	return i, err
}

const getRecentCompletedWorkouts = `-- name: GetRecentCompletedWorkouts :many

SELECT
    ws.id,
    ws.finished_at,
    (
        SELECT d.name
        FROM days d
        JOIN week_days wd ON d.id = wd.day_id
        JOIN weeks w ON wd.week_id = w.id
        JOIN cycles c ON w.cycle_id = c.id
        JOIN programs p ON p.cycle_id = c.id
        WHERE p.id = ups.program_id AND w.week_number = ws.week_number
        ORDER BY
            CASE wd.day_of_week
                WHEN 'MONDAY' THEN 1
                WHEN 'TUESDAY' THEN 2
                WHEN 'WEDNESDAY' THEN 3
                WHEN 'THURSDAY' THEN 4
                WHEN 'FRIDAY' THEN 5
                WHEN 'SATURDAY' THEN 6
                WHEN 'SUNDAY' THEN 7
            END ASC
        LIMIT 1 OFFSET ws.day_index
    ) AS day_name,
    (SELECT COUNT(*) FROM logged_sets ls WHERE ls.session_id = ws.id) AS sets_completed
FROM workout_sessions ws
JOIN user_program_states ups ON ws.user_program_state_id = ups.id
WHERE ups.user_id = ? AND ws.status = 'COMPLETED' AND ws.finished_at IS NOT NULL
ORDER BY ws.finished_at DESC
LIMIT ?
`

type GetRecentCompletedWorkoutsParams struct {
	UserID string `json:"user_id"`
	Limit  int64  `json:"limit"`
}

type GetRecentCompletedWorkoutsRow struct {
	ID            string         `json:"id"`
	FinishedAt    sql.NullString `json:"finished_at"`
	DayName       string         `json:"day_name"`
	SetsCompleted int64          `json:"sets_completed"`
}

// Dashboard aggregation queries
// Get recent completed workouts for a user with day name and sets completed
// day_index is used as an offset into the ordered days for the week
func (q *Queries) GetRecentCompletedWorkouts(ctx context.Context, arg GetRecentCompletedWorkoutsParams) ([]GetRecentCompletedWorkoutsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecentCompletedWorkouts, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRecentCompletedWorkoutsRow{}
	for rows.Next() {
		var i GetRecentCompletedWorkoutsRow
		if err := rows.Scan(
			&i.ID,
			&i.FinishedAt,
			&i.DayName,
			&i.SetsCompleted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
