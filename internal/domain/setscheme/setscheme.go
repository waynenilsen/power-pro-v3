// Package setscheme provides domain logic for set/rep scheme strategies.
// This package defines the interface for polymorphic set generation that can
// be extended with new schemes without modifying existing code.
package setscheme

import (
	"encoding/json"
	"errors"
	"fmt"
)

// SetSchemeType identifies the type of set scheme.
// Uses string constants for JSON serialization compatibility.
type SetSchemeType string

const (
	// TypeFixed generates identical sets at the same weight and reps (e.g., 5x5).
	TypeFixed SetSchemeType = "FIXED"
	// TypeRamp generates sets with progressive percentages across sets.
	TypeRamp SetSchemeType = "RAMP"
	// TypeAMRAP generates sets with as-many-reps-as-possible (future implementation).
	TypeAMRAP SetSchemeType = "AMRAP"
	// TypeTopBackoff generates a top set followed by backoff sets (future implementation).
	TypeTopBackoff SetSchemeType = "TOP_BACKOFF"
	// TypeRepRange generates sets with a target rep range (e.g., 3x8-12).
	TypeRepRange SetSchemeType = "REP_RANGE"
)

// ValidSchemeTypes contains all valid scheme types for validation.
var ValidSchemeTypes = map[SetSchemeType]bool{
	TypeFixed:      true,
	TypeRamp:       true,
	TypeAMRAP:      true,
	TypeTopBackoff: true,
	TypeRepRange:   true,
}

// Errors for set scheme operations.
var (
	ErrUnknownSchemeType   = errors.New("unknown set scheme type")
	ErrInvalidParams       = errors.New("invalid set scheme parameters")
	ErrSchemeNotRegistered = errors.New("scheme type not registered in factory")
)

// GeneratedSet represents a single set generated by a SetScheme.
// This is the output of the GenerateSets method.
type GeneratedSet struct {
	// SetNumber is the 1-indexed set number for user-facing display.
	SetNumber int `json:"setNumber"`
	// Weight is the target weight for this set.
	Weight float64 `json:"weight"`
	// TargetReps is the target number of repetitions.
	TargetReps int `json:"targetReps"`
	// IsWorkSet is true if this is a work set, false if warmup.
	IsWorkSet bool `json:"isWorkSet"`
}

// SetGenerationContext provides additional context for set generation.
// This struct may be extended with additional fields as needed.
type SetGenerationContext struct {
	// WorkSetThreshold is the percentage threshold above which sets are considered work sets.
	// Only applicable for schemes that use percentage-based classification (e.g., Ramp).
	// Default: 80.0 (80%)
	WorkSetThreshold float64
}

// DefaultSetGenerationContext returns a SetGenerationContext with default values.
func DefaultSetGenerationContext() SetGenerationContext {
	return SetGenerationContext{
		WorkSetThreshold: 80.0,
	}
}

// SetScheme defines the interface for all set/rep scheme strategies.
// This interface enables polymorphic set generation using the strategy pattern.
// New schemes can be added by implementing this interface without modifying
// existing code (Open/Closed Principle).
type SetScheme interface {
	// Type returns the discriminator string for this scheme.
	// This is used for JSON serialization/deserialization.
	Type() SetSchemeType

	// GenerateSets generates concrete sets from a base weight.
	// The baseWeight is typically calculated by a LoadStrategy.
	// Returns a slice of GeneratedSet or an error.
	GenerateSets(baseWeight float64, context SetGenerationContext) ([]GeneratedSet, error)

	// Validate validates the scheme's configuration parameters.
	// Returns an error if the scheme is misconfigured.
	Validate() error
}

// SchemeEnvelope is the JSON wrapper for polymorphic SetScheme serialization.
// It uses the discriminated union pattern with a "type" field.
type SchemeEnvelope struct {
	Type SetSchemeType `json:"type"`
	// Raw contains the scheme-specific JSON data (excluding the type field).
	// This is used during unmarshaling to delegate to the concrete type.
	Raw json.RawMessage `json:"-"`
}

// MarshalJSON implements json.Marshaler for SchemeEnvelope.
// This is typically not used directly; instead, use MarshalScheme.
func (e *SchemeEnvelope) MarshalJSON() ([]byte, error) {
	type Alias SchemeEnvelope
	return json.Marshal(&struct {
		*Alias
	}{
		Alias: (*Alias)(e),
	})
}

// UnmarshalJSON implements json.Unmarshaler for SchemeEnvelope.
// It extracts the type field and stores the raw JSON for later parsing.
func (e *SchemeEnvelope) UnmarshalJSON(data []byte) error {
	// First, extract just the type field
	var typeOnly struct {
		Type SetSchemeType `json:"type"`
	}
	if err := json.Unmarshal(data, &typeOnly); err != nil {
		return fmt.Errorf("failed to parse scheme type: %w", err)
	}
	e.Type = typeOnly.Type
	e.Raw = data
	return nil
}

// SchemeFactory creates SetScheme instances from their type and JSON data.
// Schemes must be registered with the factory before they can be deserialized.
type SchemeFactory struct {
	// creators maps scheme types to their constructor functions.
	// The constructor receives the raw JSON and returns the concrete scheme.
	creators map[SetSchemeType]func(json.RawMessage) (SetScheme, error)
}

// NewSchemeFactory creates a new SchemeFactory with no registered types.
func NewSchemeFactory() *SchemeFactory {
	return &SchemeFactory{
		creators: make(map[SetSchemeType]func(json.RawMessage) (SetScheme, error)),
	}
}

// Register registers a scheme constructor for a given type.
// The constructor function receives the raw JSON data and returns the concrete scheme.
func (f *SchemeFactory) Register(schemeType SetSchemeType, creator func(json.RawMessage) (SetScheme, error)) {
	f.creators[schemeType] = creator
}

// Create creates a SetScheme from a type and raw JSON data.
// Returns ErrSchemeNotRegistered if the type is not registered.
func (f *SchemeFactory) Create(schemeType SetSchemeType, data json.RawMessage) (SetScheme, error) {
	creator, ok := f.creators[schemeType]
	if !ok {
		return nil, fmt.Errorf("%w: %s", ErrSchemeNotRegistered, schemeType)
	}
	return creator(data)
}

// CreateFromJSON creates a SetScheme from raw JSON containing the type discriminator.
func (f *SchemeFactory) CreateFromJSON(data json.RawMessage) (SetScheme, error) {
	var envelope SchemeEnvelope
	if err := json.Unmarshal(data, &envelope); err != nil {
		return nil, fmt.Errorf("failed to parse scheme envelope: %w", err)
	}
	return f.Create(envelope.Type, data)
}

// IsRegistered checks if a scheme type is registered with the factory.
func (f *SchemeFactory) IsRegistered(schemeType SetSchemeType) bool {
	_, ok := f.creators[schemeType]
	return ok
}

// RegisteredTypes returns a slice of all registered scheme types.
func (f *SchemeFactory) RegisteredTypes() []SetSchemeType {
	types := make([]SetSchemeType, 0, len(f.creators))
	for t := range f.creators {
		types = append(types, t)
	}
	return types
}

// MarshalScheme serializes a SetScheme to JSON with the type discriminator.
// This is a convenience function that ensures the type field is always included.
func MarshalScheme(scheme SetScheme) ([]byte, error) {
	// Most concrete schemes should embed their Type() in their JSON struct,
	// but this provides a fallback mechanism.
	return json.Marshal(scheme)
}

// ValidateSchemeType checks if a scheme type string is valid.
func ValidateSchemeType(schemeType SetSchemeType) error {
	if schemeType == "" {
		return fmt.Errorf("%w: scheme type is required", ErrUnknownSchemeType)
	}
	if !ValidSchemeTypes[schemeType] {
		return fmt.Errorf("%w: %s", ErrUnknownSchemeType, schemeType)
	}
	return nil
}
